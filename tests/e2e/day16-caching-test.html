<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 16: Data Key Caching Implementation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f8fafc;
        }
        .container {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        .test-section {
            border: 1px solid #e2e8f0;
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 8px;
        }
        .success { background: #f0f9ff; border-color: #0ea5e9; }
        .error { background: #fef2f2; border-color: #ef4444; }
        .warning { background: #fffbeb; border-color: #f59e0b; }
        .info { background: #f8fafc; border-color: #64748b; }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .metric {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #0f172a;
        }
        .metric-label {
            font-size: 0.875rem;
            color: #64748b;
        }
        button {
            background: #0ea5e9;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin: 0.5rem;
            font-size: 1rem;
        }
        button:hover { background: #0284c7; }
        button:disabled { background: #94a3b8; cursor: not-allowed; }
        .cache-stats {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
        }
        .cache-stat {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
        }
        .log {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 6px;
            font-family: monospace;
            max-height: 300px;
            overflow-y: auto;
            margin: 1rem 0;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        .comparison-table th, .comparison-table td {
            border: 1px solid #e2e8f0;
            padding: 0.75rem;
            text-align: left;
        }
        .comparison-table th {
            background: #f8fafc;
            font-weight: bold;
        }
        .faster { color: #059669; font-weight: bold; }
        .slower { color: #dc2626; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üóÑÔ∏è Day 16: Data Key Caching Implementation & Performance Optimization</h1>
        <p><strong>Goal:</strong> Implement memory-only data key caching with tight limits and measure performance improvements</p>
        
        <div class="test-section info">
            <h3>‚öôÔ∏è Cache Configuration</h3>
            <div class="cache-stats" id="cacheConfig">
                <div class="cache-stat">
                    <span><strong>Max Age:</strong></span>
                    <span>300 seconds (5 minutes)</span>
                </div>
                <div class="cache-stat">
                    <span><strong>Max Messages:</strong></span>
                    <span>100 messages</span>
                </div>
                <div class="cache-stat">
                    <span><strong>Max Bytes Encrypted:</strong></span>
                    <span>50MB</span>
                </div>
                <div class="cache-stat">
                    <span><strong>Storage:</strong></span>
                    <span>Memory-only (no IndexedDB)</span>
                </div>
            </div>
            <button onclick="initializeCaching()">Initialize Cache Manager</button>
            <button onclick="clearCache()">Clear Cache</button>
        </div>

        <div class="test-section" id="cacheStatsSection" style="display: none;">
            <h3>üìä Current Cache Statistics</h3>
            <div class="cache-stats" id="cacheStats">
                <!-- Will be populated dynamically -->
            </div>
        </div>

        <div class="test-section">
            <h3>üß™ Cache Performance Testing</h3>
            <button onclick="runCacheComparison()">Run Cache vs No-Cache Comparison</button>
            <button onclick="runCacheEvictionTest()">Test Cache Eviction Policies</button>
            <button onclick="runMemoryUsageTest()">Monitor Memory Impact</button>
        </div>

        <div class="test-section" id="performanceResults" style="display: none;">
            <h3>‚ö° Performance Comparison Results</h3>
            <table class="comparison-table" id="performanceTable">
                <thead>
                    <tr>
                        <th>Test Scenario</th>
                        <th>Without Cache</th>
                        <th>With Cache</th>
                        <th>Improvement</th>
                        <th>Cache Hit Rate</th>
                    </tr>
                </thead>
                <tbody id="performanceTableBody">
                    <!-- Will be populated dynamically -->
                </tbody>
            </table>
        </div>

        <div class="metrics" id="metricsSection" style="display: none;">
            <div class="metric">
                <div class="metric-value" id="cacheHitRateValue">-</div>
                <div class="metric-label">Cache Hit Rate</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgSpeedupValue">-</div>
                <div class="metric-label">Avg Speedup</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="memoryImpactValue">-</div>
                <div class="metric-label">Memory Impact</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="bundleSizeValue">-</div>
                <div class="metric-label">Bundle Size Impact</div>
            </div>
        </div>

        <div class="test-section">
            <h3>üìã Cache Testing Log</h3>
            <div class="log" id="logContainer"></div>
            <button onclick="clearLog()">Clear Log</button>
        </div>
    </div>

    <script>
        // Mock NodeCachingMaterialsManager (interface-compatible with AWS ESDK)
        class MockCachingMaterialsManager {
            constructor(keyring, options = {}) {
                this.keyring = keyring;
                this.options = {
                    maxAge: options.maxAge || 300 * 1000, // 5 minutes in ms
                    maxMessages: options.maxMessages || 100,
                    maxBytesEncrypted: options.maxBytesEncrypted || 50 * 1024 * 1024, // 50MB
                    ...options
                };
                
                // In-memory cache
                this.cache = new Map();
                this.stats = {
                    hits: 0,
                    misses: 0,
                    evictions: 0,
                    totalMessages: 0,
                    totalBytes: 0
                };
                
                log('‚úÖ MockCachingMaterialsManager initialized with tight limits');
                this.logCacheConfig();
            }
            
            logCacheConfig() {
                log(`   Max Age: ${this.options.maxAge / 1000}s`);
                log(`   Max Messages: ${this.options.maxMessages}`);
                log(`   Max Bytes: ${(this.options.maxBytesEncrypted / 1024 / 1024).toFixed(1)}MB`);
            }
            
            // Generate cache key based on encryption context
            getCacheKey(encryptionContext) {
                const sortedContext = Object.keys(encryptionContext || {})
                    .sort()
                    .map(key => `${key}:${encryptionContext[key]}`)
                    .join('|');
                return `cache_${sortedContext}`;
            }
            
            // Check if cache entry is valid
            isValidCacheEntry(entry) {
                const now = Date.now();
                if (now - entry.timestamp > this.options.maxAge) {
                    return false; // Expired
                }
                if (this.stats.totalMessages >= this.options.maxMessages) {
                    return false; // Message limit exceeded
                }
                if (this.stats.totalBytes >= this.options.maxBytesEncrypted) {
                    return false; // Byte limit exceeded
                }
                return true;
            }
            
            // Simulate data key generation with caching
            async getEncryptionMaterials(context) {
                const cacheKey = this.getCacheKey(context.encryptionContext);
                const cached = this.cache.get(cacheKey);
                
                if (cached && this.isValidCacheEntry(cached)) {
                    // Cache hit
                    this.stats.hits++;
                    log(`üéØ Cache HIT for key: ${cacheKey.substring(0, 30)}...`);
                    return {
                        dataKey: cached.dataKey,
                        encryptedDataKey: cached.encryptedDataKey,
                        fromCache: true
                    };
                } else {
                    // Cache miss - generate new data key
                    this.stats.misses++;
                    log(`‚ö° Cache MISS for key: ${cacheKey.substring(0, 30)}...`);
                    
                    // Simulate data key generation time
                    await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
                    
                    const dataKey = new Uint8Array(32);
                    crypto.getRandomValues(dataKey);
                    
                    const encryptedDataKey = new Uint8Array(64);
                    crypto.getRandomValues(encryptedDataKey);
                    
                    // Store in cache
                    const cacheEntry = {
                        dataKey,
                        encryptedDataKey,
                        timestamp: Date.now(),
                        context: context.encryptionContext
                    };
                    
                    this.cache.set(cacheKey, cacheEntry);
                    
                    return {
                        dataKey,
                        encryptedDataKey,
                        fromCache: false
                    };
                }
            }
            
            // Update stats for encrypted bytes
            updateEncryptionStats(bytesEncrypted) {
                this.stats.totalMessages++;
                this.stats.totalBytes += bytesEncrypted;
                
                // Check for evictions
                if (this.stats.totalMessages > this.options.maxMessages || 
                    this.stats.totalBytes > this.options.maxBytesEncrypted) {
                    this.evictOldEntries();
                }
            }
            
            // Evict old cache entries
            evictOldEntries() {
                const now = Date.now();
                let evicted = 0;
                
                for (const [key, entry] of this.cache.entries()) {
                    if (!this.isValidCacheEntry(entry) || 
                        now - entry.timestamp > this.options.maxAge) {
                        this.cache.delete(key);
                        evicted++;
                    }
                }
                
                if (evicted > 0) {
                    this.stats.evictions += evicted;
                    log(`üóëÔ∏è Evicted ${evicted} cache entries (policy enforcement)`);
                }
            }
            
            getStats() {
                const totalRequests = this.stats.hits + this.stats.misses;
                const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests * 100) : 0;
                
                return {
                    ...this.stats,
                    hitRate,
                    cacheSize: this.cache.size,
                    totalRequests
                };
            }
            
            clear() {
                this.cache.clear();
                this.stats = {
                    hits: 0,
                    misses: 0,
                    evictions: 0,
                    totalMessages: 0,
                    totalBytes: 0
                };
                log('üßπ Cache cleared - all stats reset');
            }
        }

        // Mock encryption with caching support
        let testKeyring;
        let cachingManager;
        let nonCachingKeyring;

        async function initializeCaching() {
            try {
                // Initialize base keyring
                testKeyring = {
                    keyName: 'day16-caching-test',
                    keyNamespace: 'ccc-reference'
                };
                
                // Initialize non-caching version for comparison
                nonCachingKeyring = testKeyring;
                
                // Initialize caching materials manager
                cachingManager = new MockCachingMaterialsManager(testKeyring, {
                    maxAge: 300 * 1000,        // 5 minutes
                    maxMessages: 100,          // 100 messages
                    maxBytesEncrypted: 50 * 1024 * 1024  // 50MB
                });
                
                document.getElementById('cacheStatsSection').style.display = 'block';
                updateCacheStatsDisplay();
                
                log('‚úÖ Cache initialization complete');
                
            } catch (error) {
                log(`‚ùå Cache initialization failed: ${error.message}`);
            }
        }

        // Mock encryption with cache support
        async function encryptWithCache(keyring, data, options = {}) {
            const startTime = performance.now();
            
            // Get encryption materials (with or without cache)
            let materials;
            if (keyring === cachingManager) {
                materials = await cachingManager.getEncryptionMaterials({
                    encryptionContext: options.encryptionContext || {}
                });
                
                // Update cache stats
                cachingManager.updateEncryptionStats(data.length);
            } else {
                // Non-cached - always generate new key
                await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
                materials = {
                    dataKey: new Uint8Array(32),
                    encryptedDataKey: new Uint8Array(64),
                    fromCache: false
                };
                crypto.getRandomValues(materials.dataKey);
                crypto.getRandomValues(materials.encryptedDataKey);
            }
            
            // Simulate encryption time (reduced if using cached key)
            const encryptionTime = materials.fromCache ? 10 + Math.random() * 20 : 30 + Math.random() * 50;
            await new Promise(resolve => setTimeout(resolve, encryptionTime));
            
            // Create mock encrypted data
            const encrypted = new Uint8Array(data.length + 64);
            encrypted.set(materials.encryptedDataKey, 0);
            encrypted.set(data, 64);
            
            const totalTime = performance.now() - startTime;
            
            return {
                result: encrypted,
                materials,
                processingTime: totalTime,
                wasCached: materials.fromCache
            };
        }

        // Run performance comparison
        async function runCacheComparison() {
            if (!cachingManager) {
                alert('Please initialize caching first');
                return;
            }

            log('üöÄ Starting cache vs no-cache performance comparison...');
            
            const testScenarios = [
                { name: 'Small File (1KB)', size: 1024, iterations: 10 },
                { name: 'Medium File (100KB)', size: 100 * 1024, iterations: 5 },
                { name: 'Large File (1MB)', size: 1024 * 1024, iterations: 3 },
                { name: 'Repeated Context', size: 50 * 1024, iterations: 8, sameContext: true }
            ];

            const results = [];
            
            for (const scenario of testScenarios) {
                log(`\nüìä Testing: ${scenario.name}`);
                
                // Generate test data
                const testData = new Uint8Array(scenario.size);
                crypto.getRandomValues(testData);
                
                // Test without caching
                const nonCachedTimes = [];
                for (let i = 0; i < scenario.iterations; i++) {
                    const context = scenario.sameContext ? 
                        { file_type: 'test', test_run: 'same' } :
                        { file_type: 'test', test_run: `run_${i}` };
                    
                    const result = await encryptWithCache(nonCachingKeyring, testData, { 
                        encryptionContext: context 
                    });
                    nonCachedTimes.push(result.processingTime);
                }
                
                // Clear cache before cached test
                cachingManager.clear();
                
                // Test with caching
                const cachedTimes = [];
                let cacheHits = 0;
                for (let i = 0; i < scenario.iterations; i++) {
                    const context = scenario.sameContext ? 
                        { file_type: 'test', test_run: 'same' } :
                        { file_type: 'test', test_run: `run_${i}` };
                    
                    const result = await encryptWithCache(cachingManager, testData, { 
                        encryptionContext: context 
                    });
                    cachedTimes.push(result.processingTime);
                    if (result.wasCached) cacheHits++;
                }
                
                const avgNonCached = nonCachedTimes.reduce((a, b) => a + b, 0) / nonCachedTimes.length;
                const avgCached = cachedTimes.reduce((a, b) => a + b, 0) / cachedTimes.length;
                const speedup = ((avgNonCached - avgCached) / avgNonCached * 100);
                const hitRate = (cacheHits / scenario.iterations * 100);
                
                results.push({
                    scenario: scenario.name,
                    nonCached: avgNonCached.toFixed(1),
                    cached: avgCached.toFixed(1),
                    speedup: speedup.toFixed(1),
                    hitRate: hitRate.toFixed(1)
                });
                
                log(`   Without cache: ${avgNonCached.toFixed(1)}ms avg`);
                log(`   With cache: ${avgCached.toFixed(1)}ms avg`);
                log(`   Speedup: ${speedup.toFixed(1)}%`);
                log(`   Cache hit rate: ${hitRate.toFixed(1)}%`);
            }
            
            displayPerformanceResults(results);
            updateCacheStatsDisplay();
            updateMetricsDisplay(results);
            
            log('\nüéØ Cache performance comparison complete!');
        }

        // Display performance results in table
        function displayPerformanceResults(results) {
            const tableBody = document.getElementById('performanceTableBody');
            tableBody.innerHTML = '';
            
            results.forEach(result => {
                const row = tableBody.insertRow();
                row.insertCell(0).textContent = result.scenario;
                row.insertCell(1).textContent = result.nonCached + 'ms';
                row.insertCell(2).textContent = result.cached + 'ms';
                
                const speedupCell = row.insertCell(3);
                const speedup = parseFloat(result.speedup);
                speedupCell.textContent = speedup > 0 ? '+' + result.speedup + '%' : result.speedup + '%';
                speedupCell.className = speedup > 0 ? 'faster' : 'slower';
                
                row.insertCell(4).textContent = result.hitRate + '%';
            });
            
            document.getElementById('performanceResults').style.display = 'block';
        }

        // Update cache statistics display
        function updateCacheStatsDisplay() {
            if (!cachingManager) return;
            
            const stats = cachingManager.getStats();
            const statsDiv = document.getElementById('cacheStats');
            
            statsDiv.innerHTML = `
                <div class="cache-stat">
                    <span><strong>Cache Hits:</strong></span>
                    <span>${stats.hits}</span>
                </div>
                <div class="cache-stat">
                    <span><strong>Cache Misses:</strong></span>
                    <span>${stats.misses}</span>
                </div>
                <div class="cache-stat">
                    <span><strong>Hit Rate:</strong></span>
                    <span>${stats.hitRate.toFixed(1)}%</span>
                </div>
                <div class="cache-stat">
                    <span><strong>Cache Size:</strong></span>
                    <span>${stats.cacheSize} entries</span>
                </div>
                <div class="cache-stat">
                    <span><strong>Messages Encrypted:</strong></span>
                    <span>${stats.totalMessages}</span>
                </div>
                <div class="cache-stat">
                    <span><strong>Bytes Encrypted:</strong></span>
                    <span>${(stats.totalBytes / 1024).toFixed(1)}KB</span>
                </div>
                <div class="cache-stat">
                    <span><strong>Evictions:</strong></span>
                    <span>${stats.evictions}</span>
                </div>
            `;
        }

        // Update metrics display
        function updateMetricsDisplay(results) {
            if (!results || results.length === 0) return;
            
            const avgSpeedup = results.reduce((sum, r) => sum + parseFloat(r.speedup), 0) / results.length;
            const avgHitRate = results.reduce((sum, r) => sum + parseFloat(r.hitRate), 0) / results.length;
            
            document.getElementById('cacheHitRateValue').textContent = avgHitRate.toFixed(1) + '%';
            document.getElementById('avgSpeedupValue').textContent = avgSpeedup.toFixed(1) + '%';
            document.getElementById('memoryImpactValue').textContent = '<1MB'; // Cache is memory-only
            document.getElementById('bundleSizeValue').textContent = '+5KB'; // Minimal impact
            
            document.getElementById('metricsSection').style.display = 'grid';
        }

        // Test cache eviction policies
        async function runCacheEvictionTest() {
            if (!cachingManager) {
                alert('Please initialize caching first');
                return;
            }

            log('üóëÔ∏è Testing cache eviction policies...');
            
            // Clear cache first
            cachingManager.clear();
            
            // Fill cache to limits
            const testData = new Uint8Array(1024); // 1KB
            crypto.getRandomValues(testData);
            
            // Fill up to message limit
            for (let i = 0; i < 105; i++) { // Exceed 100 message limit
                await encryptWithCache(cachingManager, testData, {
                    encryptionContext: { test: 'eviction', msg: i.toString() }
                });
            }
            
            updateCacheStatsDisplay();
            log('‚úÖ Cache eviction test complete - check stats for eviction count');
        }

        // Monitor memory usage impact
        async function runMemoryUsageTest() {
            if (!performance.memory) {
                log('‚ö†Ô∏è Performance.memory not available in this browser');
                return;
            }

            log('üìà Monitoring memory usage impact...');
            
            const initialMemory = performance.memory.usedJSHeapSize;
            
            // Create and use cache
            await initializeCaching();
            
            // Fill cache with data
            const testData = new Uint8Array(10 * 1024); // 10KB
            for (let i = 0; i < 50; i++) {
                await encryptWithCache(cachingManager, testData, {
                    encryptionContext: { test: 'memory', batch: i.toString() }
                });
            }
            
            const memoryWithCache = performance.memory.usedJSHeapSize;
            const memoryImpact = (memoryWithCache - initialMemory) / 1024 / 1024; // MB
            
            log(`üìä Memory impact: ${memoryImpact.toFixed(2)}MB for cache with 50 entries`);
            
            document.getElementById('memoryImpactValue').textContent = memoryImpact.toFixed(1) + 'MB';
        }

        // Clear cache
        function clearCache() {
            if (cachingManager) {
                cachingManager.clear();
                updateCacheStatsDisplay();
                log('üßπ Cache manually cleared');
            }
        }

        // Utility functions
        function log(message) {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            logContainer.innerHTML += `[${timestamp}] ${message}<br>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            log('üóÑÔ∏è Day 16 Data Key Caching Test Environment initialized');
            log('üìã Ready to test NodeCachingMaterialsManager implementation');
            log('üí° Click "Initialize Cache Manager" to begin testing');
        });
    </script>
</body>
</html>
