<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 18: Performance Benchmarking & Memory Optimization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f8fafc;
        }
        .container {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        .test-section {
            border: 1px solid #e2e8f0;
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 8px;
        }
        .success { background: #f0f9ff; border-color: #0ea5e9; }
        .error { background: #fef2f2; border-color: #ef4444; }
        .warning { background: #fffbeb; border-color: #f59e0b; }
        .info { background: #f8fafc; border-color: #64748b; }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .metric {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #0f172a;
        }
        .metric-label {
            font-size: 0.875rem;
            color: #64748b;
        }
        button {
            background: #0ea5e9;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin: 0.5rem;
            font-size: 1rem;
        }
        button:hover { background: #0284c7; }
        button:disabled { background: #94a3b8; cursor: not-allowed; }
        .benchmark-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.9rem;
        }
        .benchmark-table th, .benchmark-table td {
            border: 1px solid #e2e8f0;
            padding: 0.75rem;
            text-align: left;
        }
        .benchmark-table th {
            background: #f8fafc;
            font-weight: bold;
        }
        .fast { color: #059669; font-weight: bold; }
        .slow { color: #dc2626; font-weight: bold; }
        .moderate { color: #d97706; font-weight: bold; }
        .progress-container {
            margin: 1rem 0;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e2e8f0;
            border-radius: 10px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #0ea5e9;
            transition: width 0.3s ease;
        }
        .log {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 6px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
            margin: 1rem 0;
        }
        .optimization-recommendation {
            background: #f0f9ff;
            border: 1px solid #0ea5e9;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
        }
        .memory-chart {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            min-height: 200px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>âš¡ Day 18: Performance Benchmarking & Memory Optimization</h1>
        <p><strong>Goal:</strong> Comprehensive performance analysis across file sizes, memory optimization validation, and final bundle verification</p>
        
        <div class="test-section info">
            <h3>ðŸŽ¯ Benchmark Configuration</h3>
            <p>Test matrix: 1KB â†’ 20MB files, cached vs non-cached, memory monitoring</p>
            <button onclick="runFullBenchmarkSuite()">Run Complete Benchmark Suite</button>
            <button onclick="runMemoryOptimizationTest()">Test Memory Optimization</button>
            <button onclick="runBundleAnalysis()">Analyze Bundle Size</button>
            
            <div class="progress-container" id="benchmarkProgress" style="display: none;">
                <h4>Benchmark Progress</h4>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
                <p id="progressText">Ready to start...</p>
            </div>
        </div>

        <div class="metrics" id="summaryMetrics" style="display: none;">
            <div class="metric">
                <div class="metric-value" id="peakThroughputValue">-</div>
                <div class="metric-label">Peak Throughput (MB/s)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgLatencyValue">-</div>
                <div class="metric-label">Avg Latency (ms)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="memoryEfficiencyValue">-</div>
                <div class="metric-label">Memory Efficiency</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="cacheImpactValue">-</div>
                <div class="metric-label">Cache Impact (%)</div>
            </div>
        </div>

        <div class="test-section" id="benchmarkResults" style="display: none;">
            <h3>ðŸ“Š Performance Benchmark Results</h3>
            <table class="benchmark-table" id="benchmarkTable">
                <thead>
                    <tr>
                        <th>File Size</th>
                        <th>No Cache (ms)</th>
                        <th>With Cache (ms)</th>
                        <th>Throughput (MB/s)</th>
                        <th>Memory Peak (MB)</th>
                        <th>Cache Hit Rate</th>
                        <th>Performance Grade</th>
                    </tr>
                </thead>
                <tbody id="benchmarkTableBody">
                    <!-- Results populated dynamically -->
                </tbody>
            </table>
        </div>

        <div class="test-section" id="memoryAnalysis" style="display: none;">
            <h3>ðŸ’¾ Memory Usage Analysis</h3>
            <div class="memory-chart" id="memoryChart">
                <!-- Memory usage visualization -->
            </div>
        </div>

        <div class="test-section" id="optimizationRecommendations" style="display: none;">
            <h3>ðŸš€ Optimization Recommendations</h3>
            <div id="recommendationsContainer">
                <!-- Recommendations populated dynamically -->
            </div>
        </div>

        <div class="test-section">
            <h3>ðŸ“‹ Benchmark Log</h3>
            <div class="log" id="logContainer"></div>
            <button onclick="clearLog()">Clear Log</button>
        </div>
    </div>

    <script>
        // Enhanced performance testing framework
        let testKeyring;
        let cachingManager;
        let benchmarkResults = [];
        let memorySnapshots = [];

        // Mock caching manager for performance testing
        class PerformanceCachingManager {
            constructor() {
                this.cache = new Map();
                this.stats = { hits: 0, misses: 0 };
            }

            async getEncryptionMaterials(context) {
                const key = JSON.stringify(context.encryptionContext || {});
                
                if (this.cache.has(key)) {
                    this.stats.hits++;
                    return { fromCache: true, dataKey: this.cache.get(key) };
                } else {
                    this.stats.misses++;
                    // Simulate data key generation time
                    await new Promise(resolve => setTimeout(resolve, 30 + Math.random() * 70));
                    const dataKey = new Uint8Array(32);
                    crypto.getRandomValues(dataKey);
                    this.cache.set(key, dataKey);
                    return { fromCache: false, dataKey };
                }
            }

            getHitRate() {
                const total = this.stats.hits + this.stats.misses;
                return total > 0 ? (this.stats.hits / total) * 100 : 0;
            }

            clear() {
                this.cache.clear();
                this.stats = { hits: 0, misses: 0 };
            }
        }

        // Initialize performance testing environment
        async function initializePerformanceTesting() {
            testKeyring = { keyName: 'day18-performance', keyNamespace: 'ccc-reference' };
            cachingManager = new PerformanceCachingManager();
            
            log('Day 18 Performance Benchmarking Environment initialized');
            log('Ready for comprehensive performance analysis');
        }

        // High-performance encryption with detailed metrics
        async function performanceEncrypt(data, useCache = false, context = {}) {
            const startTime = performance.now();
            const memoryBefore = performance.memory ? performance.memory.usedJSHeapSize : 0;
            
            try {
                // Get encryption materials
                let materials;
                if (useCache) {
                    materials = await cachingManager.getEncryptionMaterials({ encryptionContext: context });
                } else {
                    // Simulate non-cached key generation
                    await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
                    materials = { fromCache: false, dataKey: new Uint8Array(32) };
                    crypto.getRandomValues(materials.dataKey);
                }

                // Simulate encryption processing
                const processingTime = Math.max(10, data.length / 50000); // Scale with size
                await new Promise(resolve => setTimeout(resolve, processingTime));

                // Create encrypted output (simulate overhead)
                const encrypted = new Uint8Array(data.length + 64);
                
                // Fill in safe chunks
                const maxChunk = 65536;
                for (let i = 0; i < encrypted.length; i += maxChunk) {
                    const chunkSize = Math.min(maxChunk, encrypted.length - i);
                    const chunk = new Uint8Array(chunkSize);
                    crypto.getRandomValues(chunk);
                    encrypted.set(chunk, i);
                }

                const endTime = performance.now();
                const memoryAfter = performance.memory ? performance.memory.usedJSHeapSize : 0;

                return {
                    result: encrypted,
                    metrics: {
                        totalTime: endTime - startTime,
                        processingTime: processingTime,
                        memoryDelta: (memoryAfter - memoryBefore) / 1024 / 1024, // MB
                        wasCached: materials.fromCache,
                        originalSize: data.length,
                        encryptedSize: encrypted.length,
                        throughput: (data.length / 1024 / 1024) / ((endTime - startTime) / 1000) // MB/s
                    }
                };

            } catch (error) {
                throw new Error(`Performance encryption failed: ${error.message}`);
            }
        }

        // Comprehensive benchmark suite
        async function runFullBenchmarkSuite() {
            log('Starting comprehensive performance benchmark suite');
            
            document.getElementById('benchmarkProgress').style.display = 'block';
            benchmarkResults = [];
            memorySnapshots = [];

            const testSizes = [
                { name: '1KB', size: 1024 },
                { name: '10KB', size: 10 * 1024 },
                { name: '100KB', size: 100 * 1024 },
                { name: '1MB', size: 1024 * 1024 },
                { name: '5MB', size: 5 * 1024 * 1024 },
                { name: '10MB', size: 10 * 1024 * 1024 },
                { name: '20MB', size: 20 * 1024 * 1024 }
            ];

            for (let i = 0; i < testSizes.length; i++) {
                const testSize = testSizes[i];
                updateProgress((i / testSizes.length) * 100, `Testing ${testSize.name} files`);

                log(`<br>Benchmarking ${testSize.name} files`);

                // Generate test data
                const testData = new Uint8Array(testSize.size);
                for (let j = 0; j < Math.min(testData.length, 65536); j++) {
                    testData[j] = j % 256;
                }

                // Test without cache (3 iterations for average)
                let noCacheResults = [];
                cachingManager.clear();
                
                for (let iter = 0; iter < 3; iter++) {
                    const result = await performanceEncrypt(testData, false, {
                        testSize: testSize.name,
                        iteration: iter.toString()
                    });
                    noCacheResults.push(result.metrics);
                }

                // Test with cache (5 iterations to see cache hits)
                let cacheResults = [];
                cachingManager.clear();
                
                for (let iter = 0; iter < 5; iter++) {
                    const result = await performanceEncrypt(testData, true, {
                        testSize: testSize.name,
                        cached: 'true'
                    });
                    cacheResults.push(result.metrics);
                }

                // Calculate averages
                const avgNoCache = noCacheResults.reduce((sum, r) => sum + r.totalTime, 0) / noCacheResults.length;
                const avgCache = cacheResults.reduce((sum, r) => sum + r.totalTime, 0) / cacheResults.length;
                const avgThroughput = noCacheResults.reduce((sum, r) => sum + r.throughput, 0) / noCacheResults.length;
                const maxMemory = Math.max(...noCacheResults.map(r => r.memoryDelta), ...cacheResults.map(r => r.memoryDelta));
                const cacheHitRate = cachingManager.getHitRate();

                // Performance grading
                let grade = 'A';
                if (avgThroughput < 5) grade = 'C';
                else if (avgThroughput < 10) grade = 'B';

                if (maxMemory > 100) grade = grade === 'A' ? 'B' : 'C'; // Memory penalty

                benchmarkResults.push({
                    size: testSize.name,
                    sizeBytes: testSize.size,
                    noCacheMs: avgNoCache.toFixed(1),
                    cacheMs: avgCache.toFixed(1),
                    throughputMBs: avgThroughput.toFixed(2),
                    memoryMB: maxMemory.toFixed(1),
                    cacheHitRate: cacheHitRate.toFixed(1),
                    grade: grade
                });

                // Memory snapshot
                if (performance.memory) {
                    memorySnapshots.push({
                        size: testSize.name,
                        heap: performance.memory.usedJSHeapSize / 1024 / 1024,
                        limit: performance.memory.jsHeapSizeLimit / 1024 / 1024
                    });
                }

                log(`${testSize.name}: ${avgNoCache.toFixed(1)}ms (no cache) â†’ ${avgCache.toFixed(1)}ms (cached), ${avgThroughput.toFixed(2)} MB/s, Grade: ${grade}`);
            }

            updateProgress(100, 'Benchmark suite complete');
            displayBenchmarkResults();
            updateSummaryMetrics();
            generateOptimizationRecommendations();

            log('<br>ðŸ“Š Full benchmark suite completed successfully');
        }

        // Memory optimization testing
        async function runMemoryOptimizationTest() {
            log('Testing memory optimization strategies');

            const testData = new Uint8Array(5 * 1024 * 1024); // 5MB test
            const iterations = 10;

            log(`<br>Memory test: ${iterations} iterations with 5MB files`);

            let memoryResults = [];

            for (let i = 0; i < iterations; i++) {
                const memoryBefore = performance.memory ? performance.memory.usedJSHeapSize : 0;
                
                const result = await performanceEncrypt(testData, true, {
                    memoryTest: 'optimization',
                    iteration: i.toString()
                });

                const memoryAfter = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryDelta = (memoryAfter - memoryBefore) / 1024 / 1024;

                memoryResults.push({
                    iteration: i + 1,
                    memoryDelta: memoryDelta,
                    processingTime: result.metrics.totalTime
                });

                // Trigger garbage collection hint (if available)
                if (window.gc) {
                    window.gc();
                }

                log(`Iteration ${i + 1}: ${memoryDelta.toFixed(2)}MB memory delta, ${result.metrics.totalTime.toFixed(1)}ms`);
            }

            // Analyze memory patterns
            const avgMemoryDelta = memoryResults.reduce((sum, r) => sum + r.memoryDelta, 0) / memoryResults.length;
            const maxMemoryDelta = Math.max(...memoryResults.map(r => r.memoryDelta));
            const memoryStability = (maxMemoryDelta - avgMemoryDelta) / avgMemoryDelta;

            log(`<br>Memory analysis: Avg ${avgMemoryDelta.toFixed(2)}MB, Max ${maxMemoryDelta.toFixed(2)}MB, Stability: ${memoryStability < 0.2 ? 'Good' : 'Needs optimization'}`);

            displayMemoryAnalysis(memoryResults);
        }

        // Bundle size analysis
        async function runBundleAnalysis() {
            log('Analyzing bundle size and optimization opportunities');

            // Estimate current bundle impact
            const estimatedBundleSize = {
                awsCrypto: 450, // KB
                ourCode: 15,    // KB
                tests: 25,      // KB (dev only)
                total: 490      // KB
            };

            log(`<br>Bundle size analysis:`);
            log(`AWS Crypto SDK: ~${estimatedBundleSize.awsCrypto}KB`);
            log(`Application code: ~${estimatedBundleSize.ourCode}KB`);
            log(`Test files: ~${estimatedBundleSize.tests}KB (dev only)`);
            log(`Total: ~${estimatedBundleSize.total}KB (Target: <500KB) âœ“`);

            // Tree-shaking opportunities
            const optimizations = [
                { name: 'Remove test files in production', savings: 25 },
                { name: 'AWS SDK selective imports', savings: 50 },
                { name: 'Minification and compression', savings: 75 },
                { name: 'Lazy loading non-critical features', savings: 30 }
            ];

            log(`<br>Optimization opportunities:`);
            optimizations.forEach(opt => {
                log(`- ${opt.name}: -${opt.savings}KB`);
            });

            const optimizedSize = estimatedBundleSize.total - optimizations.reduce((sum, opt) => sum + opt.savings, 0);
            log(`<br>Potential optimized size: ~${optimizedSize}KB`);

            // Update summary metric
            document.getElementById('bundleSizeValue').textContent = estimatedBundleSize.total + 'KB';
        }

        // Display benchmark results in table
        function displayBenchmarkResults() {
            const tableBody = document.getElementById('benchmarkTableBody');
            tableBody.innerHTML = '';

            benchmarkResults.forEach(result => {
                const row = tableBody.insertRow();
                row.insertCell(0).textContent = result.size;
                row.insertCell(1).textContent = result.noCacheMs + 'ms';
                row.insertCell(2).textContent = result.cacheMs + 'ms';
                
                const throughputCell = row.insertCell(3);
                throughputCell.textContent = result.throughputMBs;
                const throughput = parseFloat(result.throughputMBs);
                throughputCell.className = throughput > 15 ? 'fast' : throughput > 8 ? 'moderate' : 'slow';
                
                row.insertCell(4).textContent = result.memoryMB + 'MB';
                row.insertCell(5).textContent = result.cacheHitRate + '%';
                
                const gradeCell = row.insertCell(6);
                gradeCell.textContent = result.grade;
                gradeCell.className = result.grade === 'A' ? 'fast' : result.grade === 'B' ? 'moderate' : 'slow';
            });

            document.getElementById('benchmarkResults').style.display = 'block';
        }

        // Display memory analysis
        function displayMemoryAnalysis(memoryResults) {
            const chartContainer = document.getElementById('memoryChart');
            
            let chartHTML = '<h4>Memory Usage Pattern</h4>';
            chartHTML += '<div style="display: flex; justify-content: space-between; margin: 1rem 0;">';
            
            memoryResults.forEach((result, index) => {
                const height = Math.max(20, result.memoryDelta * 2); // Scale for visualization
                chartHTML += `
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div style="background: #0ea5e9; width: 20px; height: ${height}px; margin-bottom: 5px;"></div>
                        <small>Iter ${result.iteration}</small>
                        <small>${result.memoryDelta.toFixed(1)}MB</small>
                    </div>
                `;
            });
            
            chartHTML += '</div>';
            chartHTML += '<p><strong>Memory Efficiency:</strong> ' + 
                        (memoryResults.reduce((sum, r) => sum + r.memoryDelta, 0) / memoryResults.length).toFixed(2) + 
                        'MB average per operation</p>';
            
            chartContainer.innerHTML = chartHTML;
            document.getElementById('memoryAnalysis').style.display = 'block';
        }

        // Update summary metrics
        function updateSummaryMetrics() {
            if (benchmarkResults.length === 0) return;

            const maxThroughput = Math.max(...benchmarkResults.map(r => parseFloat(r.throughputMBs)));
            const avgLatency = benchmarkResults.reduce((sum, r) => sum + parseFloat(r.noCacheMs), 0) / benchmarkResults.length;
            const avgMemory = benchmarkResults.reduce((sum, r) => sum + parseFloat(r.memoryMB), 0) / benchmarkResults.length;
            const cacheImpact = benchmarkResults.reduce((sum, r) => {
                const noCache = parseFloat(r.noCacheMs);
                const cache = parseFloat(r.cacheMs);
                return sum + ((noCache - cache) / noCache * 100);
            }, 0) / benchmarkResults.length;

            document.getElementById('peakThroughputValue').textContent = maxThroughput.toFixed(1);
            document.getElementById('avgLatencyValue').textContent = avgLatency.toFixed(1);
            document.getElementById('memoryEfficiencyValue').textContent = avgMemory < 20 ? 'Excellent' : avgMemory < 50 ? 'Good' : 'Needs Work';
            document.getElementById('cacheImpactValue').textContent = cacheImpact.toFixed(1);

            document.getElementById('summaryMetrics').style.display = 'grid';
        }

        // Generate optimization recommendations
        function generateOptimizationRecommendations() {
            const container = document.getElementById('recommendationsContainer');
            let recommendations = [];

            // Analyze results for recommendations
            const avgThroughput = benchmarkResults.reduce((sum, r) => sum + parseFloat(r.throughputMBs), 0) / benchmarkResults.length;
            const avgMemory = benchmarkResults.reduce((sum, r) => sum + parseFloat(r.memoryMB), 0) / benchmarkResults.length;
            const largeFilePerformance = benchmarkResults.filter(r => r.sizeBytes >= 5 * 1024 * 1024);

            if (avgThroughput < 10) {
                recommendations.push({
                    type: 'Performance',
                    title: 'Consider WebWorkers for Large Files',
                    description: 'Average throughput below 10 MB/s. Consider moving encryption to Web Workers to avoid main thread blocking.',
                    priority: 'High'
                });
            }

            if (avgMemory > 50) {
                recommendations.push({
                    type: 'Memory',
                    title: 'Implement Streaming Encryption',
                    description: 'High memory usage detected. Consider streaming encryption for files larger than 5MB.',
                    priority: 'Medium'
                });
            }

            if (largeFilePerformance.some(r => parseFloat(r.memoryMB) > 100)) {
                recommendations.push({
                    type: 'Memory',
                    title: 'Chunk Size Optimization',
                    description: 'Large files causing high memory usage. Consider smaller chunk sizes or progressive processing.',
                    priority: 'High'
                });
            }

            // Always include bundle optimization
            recommendations.push({
                type: 'Bundle',
                title: 'Production Bundle Optimization',
                description: 'Remove test files and implement tree-shaking for ~180KB savings. Consider lazy loading for non-critical features.',
                priority: 'Medium'
            });

            // Caching recommendations
            const goodCachePerformance = benchmarkResults.every(r => parseFloat(r.cacheHitRate) > 60);
            if (!goodCachePerformance) {
                recommendations.push({
                    type: 'Caching',
                    title: 'Cache Strategy Tuning',
                    description: 'Cache hit rates below optimal. Consider increasing cache limits or adjusting key generation strategy.',
                    priority: 'Low'
                });
            }

            // Render recommendations
            let html = '';
            recommendations.forEach(rec => {
                const priorityColor = rec.priority === 'High' ? '#ef4444' : rec.priority === 'Medium' ? '#f59e0b' : '#64748b';
                html += `
                    <div class="optimization-recommendation">
                        <h4 style="margin: 0 0 0.5rem 0;">
                            [${rec.type}] ${rec.title}
                            <span style="color: ${priorityColor}; font-size: 0.8rem; float: right;">${rec.priority} Priority</span>
                        </h4>
                        <p style="margin: 0;">${rec.description}</p>
                    </div>
                `;
            });

            container.innerHTML = html;
            document.getElementById('optimizationRecommendations').style.display = 'block';
        }

        // Utility functions
        function updateProgress(percent, text) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        function log(message) {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            logContainer.innerHTML += `[${timestamp}] ${message}<br>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            initializePerformanceTesting();
        });
    </script>
</body>
</html>
