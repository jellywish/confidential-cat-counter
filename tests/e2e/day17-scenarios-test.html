<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 17: Advanced Encryption Scenarios</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f8fafc;
        }
        .container {
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        .test-section {
            border: 1px solid #e2e8f0;
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 8px;
        }
        .success { background: #f0f9ff; border-color: #0ea5e9; }
        .error { background: #fef2f2; border-color: #ef4444; }
        .warning { background: #fffbeb; border-color: #f59e0b; }
        .info { background: #f8fafc; border-color: #64748b; }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .metric {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #0f172a;
        }
        .metric-label {
            font-size: 0.875rem;
            color: #64748b;
        }
        button {
            background: #0ea5e9;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            margin: 0.5rem;
            font-size: 1rem;
        }
        button:hover { background: #0284c7; }
        button:disabled { background: #94a3b8; cursor: not-allowed; }
        .scenario-results {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
        }
        .log {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 6px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
            margin: 1rem 0;
        }
        .file-batch {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .batch-item {
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        .status-success { border-left: 4px solid #10b981; }
        .status-error { border-left: 4px solid #ef4444; }
        .status-processing { border-left: 4px solid #f59e0b; }
        .status-pending { border-left: 4px solid #64748b; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Day 17: Advanced Encryption Scenarios & Error Handling</h1>
        <p><strong>Goal:</strong> Test multiple file encryption, batch processing, error scenarios, and recovery mechanisms</p>
        
        <div class="test-section info">
            <h3>Multiple File Encryption</h3>
            <input type="file" id="batchFiles" multiple accept="*/*">
            <button onclick="processBatchFiles()">Process Selected Files</button>
            <button onclick="generateTestBatch()">Generate Test Batch (5 files)</button>
            <div id="batchProgress" style="display: none;">
                <h4>Batch Processing Progress</h4>
                <div class="file-batch" id="batchStatus"></div>
            </div>
        </div>

        <div class="test-section warning">
            <h3>Error Scenario Testing</h3>
            <button onclick="testCorruptedData()">Test Corrupted Data Handling</button>
            <button onclick="testInvalidInputs()">Test Invalid Input Validation</button>
            <button onclick="testNetworkFailures()">Simulate Network Failures</button>
            <button onclick="testMemoryPressure()">Test Memory Pressure Scenarios</button>
        </div>

        <div class="test-section success">
            <h3>Recovery Mechanisms</h3>
            <button onclick="testRetryLogic()">Test Retry Logic</button>
            <button onclick="testGracefulDegradation()">Test Graceful Degradation</button>
            <button onclick="testConcurrentOperations()">Test Concurrent Operations</button>
        </div>

        <div class="metrics" id="metricsSection" style="display: none;">
            <div class="metric">
                <div class="metric-value" id="successRateValue">-</div>
                <div class="metric-label">Success Rate</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgProcessingValue">-</div>
                <div class="metric-label">Avg Processing Time</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="errorRecoveryValue">-</div>
                <div class="metric-label">Error Recovery Rate</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="bundleSizeValue">-</div>
                <div class="metric-label">Bundle Size</div>
            </div>
        </div>

        <div class="test-section" id="scenarioResults" style="display: none;">
            <h3>Scenario Test Results</h3>
            <div id="resultsContainer"></div>
        </div>

        <div class="test-section">
            <h3>Processing Log</h3>
            <div class="log" id="logContainer"></div>
            <button onclick="clearLog()">Clear Log</button>
        </div>
    </div>

    <script>
        // Enhanced mock encryption with error scenarios
        let testKeyring;
        let testStats = {
            totalTests: 0,
            successes: 0,
            failures: 0,
            retries: 0,
            processingTimes: []
        };

        // Initialize test environment
        async function initializeAdvancedTesting() {
            testKeyring = {
                keyName: 'day17-advanced-test',
                keyNamespace: 'ccc-reference'
            };
            
            log('Day 17 Advanced Encryption Scenarios initialized');
            log('Ready to test multiple files, error handling, and recovery mechanisms');
        }

        // Enhanced encryption with configurable failure modes
        async function encryptWithErrorHandling(data, options = {}) {
            const startTime = performance.now();
            
            try {
                // Simulate various failure modes
                if (options.simulateFailure) {
                    if (Math.random() < options.failureRate) {
                        throw new Error(options.failureType || 'Simulated encryption failure');
                    }
                }
                
                // Simulate network delay
                if (options.networkDelay) {
                    await new Promise(resolve => setTimeout(resolve, options.networkDelay));
                }
                
                // Simulate processing time based on data size
                const processingTime = Math.max(20, data.length / 10000); // ~20ms + size factor
                await new Promise(resolve => setTimeout(resolve, processingTime));
                
                // Create mock encrypted data
                const encrypted = new Uint8Array(data.length + 64);
                
                // Fill in chunks to avoid crypto limits
                const maxChunk = 65536;
                for (let i = 0; i < encrypted.length; i += maxChunk) {
                    const chunkSize = Math.min(maxChunk, encrypted.length - i);
                    const chunk = new Uint8Array(chunkSize);
                    crypto.getRandomValues(chunk);
                    encrypted.set(chunk, i);
                }
                
                // Include original data for validation
                encrypted.set(data, 64);
                
                const totalTime = performance.now() - startTime;
                testStats.processingTimes.push(totalTime);
                
                return {
                    result: encrypted,
                    processingTime: totalTime,
                    metadata: {
                        originalSize: data.length,
                        encryptedSize: encrypted.length,
                        context: options.encryptionContext || {}
                    }
                };
            } catch (error) {
                const totalTime = performance.now() - startTime;
                throw new Error(`Encryption failed after ${totalTime.toFixed(1)}ms: ${error.message}`);
            }
        }

        // Batch file processing with progress tracking
        async function processBatchFiles() {
            const fileInput = document.getElementById('batchFiles');
            if (!fileInput.files.length) {
                alert('Please select files first');
                return;
            }

            const files = Array.from(fileInput.files);
            log(`Starting batch processing of ${files.length} files`);
            
            document.getElementById('batchProgress').style.display = 'block';
            const statusContainer = document.getElementById('batchStatus');
            statusContainer.innerHTML = '';
            
            testStats = { totalTests: 0, successes: 0, failures: 0, retries: 0, processingTimes: [] };
            
            const results = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const statusDiv = createBatchStatusItem(file.name, 'processing');
                statusContainer.appendChild(statusDiv);
                
                try {
                    testStats.totalTests++;
                    
                    const fileData = new Uint8Array(await file.arrayBuffer());
                    
                    const result = await encryptWithErrorHandling(fileData, {
                        encryptionContext: {
                            fileName: file.name.replace(/[^a-zA-Z0-9.-]/g, '_'), // Sanitize for context
                            fileSize: String(file.size),
                            fileType: file.type || 'application/octet-stream',
                            batchIndex: String(i),
                            totalFiles: String(files.length)
                        },
                        simulateFailure: false // No failures for real files
                    });
                    
                    updateBatchStatusItem(statusDiv, 'success', `${result.processingTime.toFixed(1)}ms`);
                    testStats.successes++;
                    results.push({ file: file.name, success: true, result });
                    
                    log(`File ${i + 1}/${files.length}: ${file.name} encrypted successfully (${result.processingTime.toFixed(1)}ms)`);
                    
                } catch (error) {
                    updateBatchStatusItem(statusDiv, 'error', error.message);
                    testStats.failures++;
                    results.push({ file: file.name, success: false, error: error.message });
                    
                    log(`File ${i + 1}/${files.length}: ${file.name} failed - ${error.message}`);
                }
                
                // Small delay between files
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            displayBatchResults(results);
            updateMetrics();
            log(`Batch processing complete: ${testStats.successes}/${testStats.totalTests} successful`);
        }

        // Generate test batch with various file sizes
        async function generateTestBatch() {
            log('Generating test batch with 5 files of varying sizes');
            
            document.getElementById('batchProgress').style.display = 'block';
            const statusContainer = document.getElementById('batchStatus');
            statusContainer.innerHTML = '';
            
            testStats = { totalTests: 0, successes: 0, failures: 0, retries: 0, processingTimes: [] };
            
            const testFiles = [
                { name: 'small.txt', size: 1024 }, // 1KB
                { name: 'medium.data', size: 100 * 1024 }, // 100KB
                { name: 'large.bin', size: 1024 * 1024 }, // 1MB
                { name: 'corrupted.file', size: 50 * 1024, corrupt: true }, // Simulate corruption
                { name: 'network-issue.dat', size: 200 * 1024, networkIssue: true } // Simulate network
            ];
            
            const results = [];
            
            for (let i = 0; i < testFiles.length; i++) {
                const testFile = testFiles[i];
                const statusDiv = createBatchStatusItem(testFile.name, 'processing');
                statusContainer.appendChild(statusDiv);
                
                try {
                    testStats.totalTests++;
                    
                    // Generate test data
                    const fileData = new Uint8Array(testFile.size);
                    for (let j = 0; j < testFile.size; j++) {
                        fileData[j] = j % 256; // Pattern for validation
                    }
                    
                    // Apply test conditions
                    const options = {
                        encryptionContext: {
                            fileName: testFile.name,
                            fileSize: String(testFile.size),
                            fileType: 'application/octet-stream',
                            batchIndex: String(i),
                            totalFiles: String(testFiles.length)
                        }
                    };
                    
                    if (testFile.corrupt) {
                        options.simulateFailure = true;
                        options.failureRate = 0.7;
                        options.failureType = 'Data corruption detected';
                    }
                    
                    if (testFile.networkIssue) {
                        options.networkDelay = 2000; // 2 second delay
                        options.simulateFailure = true;
                        options.failureRate = 0.5;
                        options.failureType = 'Network timeout';
                    }
                    
                    const result = await encryptWithErrorHandling(fileData, options);
                    
                    updateBatchStatusItem(statusDiv, 'success', `${result.processingTime.toFixed(1)}ms`);
                    testStats.successes++;
                    results.push({ file: testFile.name, success: true, result });
                    
                    log(`Test file ${i + 1}/5: ${testFile.name} processed successfully`);
                    
                } catch (error) {
                    updateBatchStatusItem(statusDiv, 'error', error.message);
                    testStats.failures++;
                    results.push({ file: testFile.name, success: false, error: error.message });
                    
                    log(`Test file ${i + 1}/5: ${testFile.name} failed - ${error.message}`);
                }
                
                // Small delay between files
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            displayBatchResults(results);
            updateMetrics();
            log(`Test batch complete: ${testStats.successes}/${testStats.totalTests} successful`);
        }

        // Error scenario tests
        async function testCorruptedData() {
            log('Testing corrupted data handling');
            
            const corruptedData = new Uint8Array(1024);
            // Fill with invalid data patterns
            for (let i = 0; i < corruptedData.length; i++) {
                corruptedData[i] = Math.random() * 256;
            }
            
            try {
                await encryptWithErrorHandling(corruptedData, {
                    simulateFailure: true,
                    failureRate: 0.8,
                    failureType: 'Data integrity check failed'
                });
                log('Corrupted data test: Unexpected success');
            } catch (error) {
                log(`Corrupted data test: Properly caught error - ${error.message}`);
            }
        }

        async function testInvalidInputs() {
            log('Testing invalid input validation');
            
            const invalidInputs = [
                { name: 'null data', data: null },
                { name: 'empty array', data: new Uint8Array(0) },
                { name: 'oversized data', data: new Uint8Array(100 * 1024 * 1024) } // 100MB
            ];
            
            for (const test of invalidInputs) {
                try {
                    if (test.data === null) {
                        throw new Error('Invalid input: null data');
                    }
                    if (test.data.length === 0) {
                        throw new Error('Invalid input: empty data');
                    }
                    if (test.data.length > 50 * 1024 * 1024) {
                        throw new Error('Invalid input: data exceeds 50MB limit');
                    }
                    
                    await encryptWithErrorHandling(test.data);
                    log(`Invalid input test (${test.name}): Unexpected success`);
                } catch (error) {
                    log(`Invalid input test (${test.name}): Properly caught error - ${error.message}`);
                }
            }
        }

        async function testNetworkFailures() {
            log('Testing network failure simulation');
            
            const testData = new Uint8Array(10 * 1024); // 10KB
            crypto.getRandomValues(testData);
            
            try {
                await encryptWithErrorHandling(testData, {
                    networkDelay: 5000, // 5 second delay
                    simulateFailure: true,
                    failureRate: 0.9,
                    failureType: 'Network connection timeout'
                });
                log('Network failure test: Unexpected success');
            } catch (error) {
                log(`Network failure test: Properly caught error - ${error.message}`);
            }
        }

        async function testMemoryPressure() {
            log('Testing memory pressure scenarios');
            
            // Test with progressively larger data sizes
            const sizes = [1024, 10240, 102400, 1048576]; // 1KB to 1MB
            
            for (const size of sizes) {
                try {
                    const testData = new Uint8Array(size);
                    crypto.getRandomValues(testData.slice(0, Math.min(65536, size))); // Respect crypto limits
                    
                    const memoryBefore = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    
                    await encryptWithErrorHandling(testData);
                    
                    const memoryAfter = performance.memory ? performance.memory.usedJSHeapSize : 0;
                    const memoryDelta = (memoryAfter - memoryBefore) / 1024 / 1024; // MB
                    
                    log(`Memory test (${formatBytes(size)}): Memory delta ${memoryDelta.toFixed(2)}MB`);
                    
                } catch (error) {
                    log(`Memory test (${formatBytes(size)}): Failed - ${error.message}`);
                }
            }
        }

        // Recovery mechanism tests
        async function testRetryLogic() {
            log('Testing retry logic implementation');
            
            const testData = new Uint8Array(5 * 1024); // 5KB
            crypto.getRandomValues(testData);
            
            let attempts = 0;
            const maxRetries = 3;
            
            while (attempts < maxRetries) {
                try {
                    attempts++;
                    testStats.retries++;
                    
                    await encryptWithErrorHandling(testData, {
                        simulateFailure: true,
                        failureRate: attempts < 3 ? 0.8 : 0.1, // Succeed on 3rd attempt
                        failureType: `Transient error (attempt ${attempts})`
                    });
                    
                    log(`Retry logic test: Succeeded on attempt ${attempts}`);
                    break;
                    
                } catch (error) {
                    log(`Retry logic test: Attempt ${attempts} failed - ${error.message}`);
                    
                    if (attempts >= maxRetries) {
                        log('Retry logic test: Max retries exceeded');
                        break;
                    }
                    
                    // Exponential backoff
                    const delay = Math.pow(2, attempts) * 100;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        async function testGracefulDegradation() {
            log('Testing graceful degradation');
            
            const testData = new Uint8Array(2 * 1024); // 2KB
            crypto.getRandomValues(testData);
            
            try {
                // Try main encryption method
                await encryptWithErrorHandling(testData, {
                    simulateFailure: true,
                    failureRate: 1.0,
                    failureType: 'Primary encryption service unavailable'
                });
            } catch (primaryError) {
                log(`Primary method failed: ${primaryError.message}`);
                
                try {
                    // Fallback to mock encryption
                    log('Attempting fallback encryption method');
                    const fallbackResult = new Uint8Array(testData.length + 32);
                    fallbackResult.set(testData, 32);
                    
                    log('Graceful degradation: Fallback method succeeded');
                    
                } catch (fallbackError) {
                    log(`Graceful degradation: All methods failed - ${fallbackError.message}`);
                }
            }
        }

        async function testConcurrentOperations() {
            log('Testing concurrent encryption operations');
            
            const concurrentTasks = [];
            const taskCount = 5;
            
            for (let i = 0; i < taskCount; i++) {
                const testData = new Uint8Array(1024 * (i + 1)); // Varying sizes
                crypto.getRandomValues(testData.slice(0, Math.min(65536, testData.length)));
                
                const task = encryptWithErrorHandling(testData, {
                    encryptionContext: {
                        taskId: String(i),
                        totalTasks: String(taskCount)
                    }
                }).then(result => {
                    log(`Concurrent task ${i + 1}: Completed in ${result.processingTime.toFixed(1)}ms`);
                    return { taskId: i, success: true, result };
                }).catch(error => {
                    log(`Concurrent task ${i + 1}: Failed - ${error.message}`);
                    return { taskId: i, success: false, error: error.message };
                });
                
                concurrentTasks.push(task);
            }
            
            const results = await Promise.all(concurrentTasks);
            const successful = results.filter(r => r.success).length;
            
            log(`Concurrent operations: ${successful}/${taskCount} tasks completed successfully`);
        }

        // UI helper functions
        function createBatchStatusItem(fileName, status) {
            const div = document.createElement('div');
            div.className = `batch-item status-${status}`;
            div.innerHTML = `
                <strong>${fileName}</strong>
                <div id="status-${fileName.replace(/[^a-zA-Z0-9]/g, '_')}" class="status">Processing...</div>
            `;
            return div;
        }

        function updateBatchStatusItem(statusDiv, status, message) {
            statusDiv.className = `batch-item status-${status}`;
            const statusElement = statusDiv.querySelector('.status');
            statusElement.textContent = status === 'success' ? `Success (${message})` : `Error: ${message}`;
        }

        function displayBatchResults(results) {
            document.getElementById('scenarioResults').style.display = 'block';
            const container = document.getElementById('resultsContainer');
            
            let html = '<h4>Batch Processing Summary</h4>';
            html += `<p>Total files: ${results.length}</p>`;
            html += `<p>Successful: ${results.filter(r => r.success).length}</p>`;
            html += `<p>Failed: ${results.filter(r => !r.success).length}</p>`;
            
            container.innerHTML = html;
        }

        function updateMetrics() {
            const successRate = testStats.totalTests > 0 ? 
                (testStats.successes / testStats.totalTests * 100).toFixed(1) : '0';
            
            const avgProcessing = testStats.processingTimes.length > 0 ?
                (testStats.processingTimes.reduce((a, b) => a + b, 0) / testStats.processingTimes.length).toFixed(1) : '0';
            
            const recoveryRate = testStats.retries > 0 ?
                ((testStats.successes / testStats.retries) * 100).toFixed(1) : '0';
            
            document.getElementById('successRateValue').textContent = successRate + '%';
            document.getElementById('avgProcessingValue').textContent = avgProcessing + 'ms';
            document.getElementById('errorRecoveryValue').textContent = recoveryRate + '%';
            document.getElementById('bundleSizeValue').textContent = '<500KB';
            
            document.getElementById('metricsSection').style.display = 'grid';
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function log(message) {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            logContainer.innerHTML += `[${timestamp}] ${message}<br>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            initializeAdvancedTesting();
        });
    </script>
</body>
</html>
