<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 10: Boundary & Error Testing</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #00ff00; }
        .test-result { margin: 10px 0; padding: 10px; border: 1px solid #333; }
        .success { border-color: #00ff00; background: #001100; }
        .error { border-color: #ff0000; background: #110000; }
        .info { border-color: #0080ff; background: #000011; }
        .warning { border-color: #ffaa00; background: #110800; }
        pre { margin: 5px 0; white-space: pre-wrap; }
        button { padding: 10px; margin: 5px; background: #333; color: #00ff00; border: 1px solid #666; cursor: pointer; }
        button:hover { background: #444; }
        .test-category { margin: 20px 0; padding: 15px; border: 2px solid #444; background: #111; }
        .test-category h3 { margin-top: 0; color: #ffaa00; }
    </style>
</head>
<body>
    <h1>Day 10: Type Safety + Boundary Error Testing</h1>
    <p>Testing error handling, type safety, and fail-closed behavior</p>
    
    <div class="test-category">
        <h3>Test Categories</h3>
        <button onclick="testTypeSafety()">Type Safety Tests</button>
        <button onclick="testInputValidation()">Input Validation Tests</button>
        <button onclick="testFailClosed()">Fail-Closed Tests</button>
        <button onclick="testErrorHandling()">Error Handling Tests</button>
        <button onclick="runAllBoundaryTests()">Run All Boundary Tests</button>
        <button onclick="clearResults()">Clear Results</button>
    </div>
    
    <div id="test-results"></div>

    <!-- Include crypto logger -->
    <script src="utils/cryptoLogger.js"></script>
    
    <script>
        const results = document.getElementById('test-results');
        
        function addResult(type, title, content) {
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = `<strong>${title}</strong><pre>${content}</pre>`;
            results.appendChild(div);
        }

        function clearResults() {
            results.innerHTML = '';
        }

        // Enhanced crypto class with boundary testing
        class BoundaryTestCrypto {
            constructor() {
                this.initialized = false;
                this.keyBytes = null;
                this.cryptoKey = null;
                this.keyName = 'boundary-test-key';
                this.algorithm = 'AES-256-GCM';
            }

            async initialize() {
                if (this.initialized) return;

                // Check WebCrypto availability (fail-closed)
                if (!window.crypto || !window.crypto.subtle) {
                    throw new Error('WebCrypto API not available - encryption blocked');
                }

                // Generate and import key
                this.keyBytes = new Uint8Array(32);
                crypto.getRandomValues(this.keyBytes);

                this.cryptoKey = await window.crypto.subtle.importKey(
                    'raw',
                    this.keyBytes,
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt', 'decrypt']
                );

                this.initialized = true;
            }

            // Type-safe data conversion with validation
            validateAndConvertInput(data) {
                if (data === null || data === undefined) {
                    throw new Error('Null or undefined input not allowed');
                }

                if (data instanceof Uint8Array) {
                    return data;
                } else if (data instanceof File || data instanceof Blob) {
                    // Return promise for async conversion
                    return data.arrayBuffer().then(buffer => new Uint8Array(buffer));
                } else if (typeof data === 'string') {
                    if (data.length > 1000000) { // 1MB text limit
                        throw new Error('Text input too large (>1MB)');
                    }
                    return new TextEncoder().encode(data);
                } else if (typeof data === 'number') {
                    throw new Error('Number input not supported - convert to string first');
                } else if (typeof data === 'object') {
                    throw new Error('Object input not supported - serialize to JSON string first');
                } else {
                    throw new Error(`Unsupported input type: ${typeof data}`);
                }
            }

            // Validate encryption context for PII leakage
            validateEncryptionContext(context) {
                if (!context || typeof context !== 'object') {
                    throw new Error('Encryption context must be a valid object');
                }

                // Check for PII fields
                const piiFields = ['filename', 'name', 'username', 'email', 'ip', 'path', 'address'];
                const contextKeys = Object.keys(context).map(k => k.toLowerCase());
                
                const piiFound = piiFields.some(field => 
                    contextKeys.some(key => key.includes(field))
                );

                if (piiFound) {
                    throw new Error('PII detected in encryption context - not allowed');
                }

                // Check for required fields
                const requiredFields = ['app', 'version'];
                const missingFields = requiredFields.filter(field => !context[field]);
                
                if (missingFields.length > 0) {
                    throw new Error(`Missing required encryption context fields: ${missingFields.join(', ')}`);
                }

                return true;
            }

            async encrypt(data, encryptionContext = {}) {
                if (!this.initialized) {
                    await this.initialize();
                }

                // Validate inputs
                this.validateEncryptionContext(encryptionContext);
                
                let dataBytes;
                try {
                    const converted = this.validateAndConvertInput(data);
                    dataBytes = converted instanceof Promise ? await converted : converted;
                } catch (error) {
                    throw new Error(`Input validation failed: ${error.message}`);
                }

                // Check size limits
                if (dataBytes.length > 20 * 1024 * 1024) { // 20MB limit
                    throw new Error('Data too large (>20MB) - chunking required');
                }

                if (dataBytes.length === 0) {
                    throw new Error('Empty data not allowed');
                }

                // Generate IV
                const iv = new Uint8Array(12);
                crypto.getRandomValues(iv);

                // Encrypt
                const encryptedBuffer = await window.crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    this.cryptoKey,
                    dataBytes
                );

                const encryptedBytes = new Uint8Array(encryptedBuffer);
                const envelope = new Uint8Array(iv.length + encryptedBytes.length);
                envelope.set(iv, 0);
                envelope.set(encryptedBytes, iv.length);

                // Convert to base64 with validation
                const ciphertext = btoa(String.fromCharCode(...envelope));
                
                // Validate result is valid base64
                try {
                    atob(ciphertext);
                } catch (error) {
                    throw new Error('Base64 encoding validation failed');
                }

                return {
                    ciphertext: ciphertext,
                    algorithm: this.algorithm,
                    keyId: this.keyName,
                    encryptionContext: { ...encryptionContext },
                    timestamp: new Date().toISOString(),
                    originalSize: dataBytes.length,
                    encryptedSize: ciphertext.length
                };
            }

            async decrypt(encryptedData) {
                if (!this.initialized) {
                    await this.initialize();
                }

                // Validate encrypted data structure
                if (!encryptedData || typeof encryptedData !== 'object') {
                    throw new Error('Invalid encrypted data structure');
                }

                if (!encryptedData.ciphertext || typeof encryptedData.ciphertext !== 'string') {
                    throw new Error('Missing or invalid ciphertext');
                }

                if (!encryptedData.algorithm || encryptedData.algorithm !== this.algorithm) {
                    throw new Error('Algorithm mismatch - decryption blocked');
                }

                // Validate base64
                let envelopeBytes;
                try {
                    envelopeBytes = new Uint8Array(
                        atob(encryptedData.ciphertext)
                            .split('')
                            .map(char => char.charCodeAt(0))
                    );
                } catch (error) {
                    throw new Error('Invalid base64 ciphertext');
                }

                // Validate envelope size
                if (envelopeBytes.length < 12) {
                    throw new Error('Ciphertext too short - missing IV');
                }

                // Extract IV and encrypted data
                const iv = envelopeBytes.slice(0, 12);
                const encryptedBytes = envelopeBytes.slice(12);

                // Decrypt
                const decryptedBuffer = await window.crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    this.cryptoKey,
                    encryptedBytes
                );

                const decryptedBytes = new Uint8Array(decryptedBuffer);

                return {
                    success: true,
                    data: decryptedBytes,
                    originalSize: encryptedData.originalSize,
                    decryptedAt: new Date().toISOString()
                };
            }
        }

        const boundaryTestCrypto = new BoundaryTestCrypto();

        async function testTypeSafety() {
            addResult('info', 'Type Safety Tests Started', 'Testing type validation and conversion');

            const testCases = [
                // Valid cases
                { name: 'Valid string', data: 'test', shouldSucceed: true },
                { name: 'Valid Uint8Array', data: new Uint8Array([1, 2, 3]), shouldSucceed: true },
                { name: 'Valid empty string', data: '', shouldSucceed: false }, // Empty data not allowed
                
                // Invalid cases  
                { name: 'Null input', data: null, shouldSucceed: false },
                { name: 'Undefined input', data: undefined, shouldSucceed: false },
                { name: 'Number input', data: 42, shouldSucceed: false },
                { name: 'Object input', data: { test: 'value' }, shouldSucceed: false },
                { name: 'Array input', data: [1, 2, 3], shouldSucceed: false },
                { name: 'Function input', data: () => {}, shouldSucceed: false },
                { name: 'Very large string', data: 'x'.repeat(2000000), shouldSucceed: false }
            ];

            for (const testCase of testCases) {
                try {
                    await boundaryTestCrypto.encrypt(testCase.data, {
                        app: 'ccc-reference',
                        version: 'phase2'
                    });
                    
                    if (testCase.shouldSucceed) {
                        addResult('success', `Type Safety: ${testCase.name}`, 'âœ… Correctly accepted valid input');
                    } else {
                        addResult('error', `Type Safety: ${testCase.name}`, 'âŒ SECURITY ISSUE: Accepted invalid input');
                    }
                } catch (error) {
                    if (testCase.shouldSucceed) {
                        addResult('error', `Type Safety: ${testCase.name}`, `âŒ Incorrectly rejected: ${error.message}`);
                    } else {
                        addResult('success', `Type Safety: ${testCase.name}`, `âœ… Correctly rejected: ${error.message}`);
                    }
                }
            }
        }

        async function testInputValidation() {
            addResult('info', 'Input Validation Tests Started', 'Testing input validation and PII detection');

            // Test encryption context validation
            const contextTestCases = [
                { name: 'Valid context', context: { app: 'ccc-reference', version: 'phase2' }, shouldSucceed: true },
                { name: 'Missing required fields', context: { app: 'ccc-reference' }, shouldSucceed: false },
                { name: 'PII in context (filename)', context: { app: 'ccc-reference', version: 'phase2', filename: 'secret.txt' }, shouldSucceed: false },
                { name: 'PII in context (email)', context: { app: 'ccc-reference', version: 'phase2', user_email: 'test@example.com' }, shouldSucceed: false },
                { name: 'Null context', context: null, shouldSucceed: false },
                { name: 'Non-object context', context: 'string', shouldSucceed: false }
            ];

            for (const testCase of contextTestCases) {
                try {
                    await boundaryTestCrypto.encrypt('test data', testCase.context);
                    
                    if (testCase.shouldSucceed) {
                        addResult('success', `Context Validation: ${testCase.name}`, 'âœ… Valid context accepted');
                    } else {
                        addResult('error', `Context Validation: ${testCase.name}`, 'âŒ SECURITY ISSUE: Invalid context accepted');
                    }
                } catch (error) {
                    if (testCase.shouldSucceed) {
                        addResult('error', `Context Validation: ${testCase.name}`, `âŒ Valid context rejected: ${error.message}`);
                    } else {
                        addResult('success', `Context Validation: ${testCase.name}`, `âœ… Invalid context rejected: ${error.message}`);
                    }
                }
            }
        }

        async function testFailClosed() {
            addResult('info', 'Fail-Closed Tests Started', 'Testing fail-closed behavior');

            // Test 1: WebCrypto unavailable
            const originalCrypto = window.crypto;
            try {
                delete window.crypto;
                
                try {
                    const testCrypto = new BoundaryTestCrypto();
                    await testCrypto.encrypt('test');
                    addResult('error', 'Fail-Closed: No WebCrypto', 'âŒ SECURITY ISSUE: Encryption succeeded without WebCrypto');
                } catch (error) {
                    addResult('success', 'Fail-Closed: No WebCrypto', `âœ… Correctly blocked: ${error.message}`);
                }
                
                // Restore WebCrypto
                window.crypto = originalCrypto;
            } catch (error) {
                window.crypto = originalCrypto;
                addResult('error', 'Fail-Closed: No WebCrypto', `Test error: ${error.message}`);
            }

            // Test 2: Corrupted ciphertext
            try {
                const encrypted = await boundaryTestCrypto.encrypt('test', { app: 'ccc-reference', version: 'phase2' });
                
                // Corrupt the ciphertext
                encrypted.ciphertext = encrypted.ciphertext.substring(0, 10) + 'CORRUPTED';
                
                try {
                    await boundaryTestCrypto.decrypt(encrypted);
                    addResult('error', 'Fail-Closed: Corrupted Data', 'âŒ SECURITY ISSUE: Decrypted corrupted data');
                } catch (error) {
                    addResult('success', 'Fail-Closed: Corrupted Data', `âœ… Correctly failed: ${error.message}`);
                }
            } catch (error) {
                addResult('error', 'Fail-Closed: Corrupted Data', `Test setup error: ${error.message}`);
            }

            // Test 3: Algorithm mismatch
            try {
                const encrypted = await boundaryTestCrypto.encrypt('test', { app: 'ccc-reference', version: 'phase2' });
                
                // Change algorithm
                encrypted.algorithm = 'WRONG-ALGORITHM';
                
                try {
                    await boundaryTestCrypto.decrypt(encrypted);
                    addResult('error', 'Fail-Closed: Algorithm Mismatch', 'âŒ SECURITY ISSUE: Accepted wrong algorithm');
                } catch (error) {
                    addResult('success', 'Fail-Closed: Algorithm Mismatch', `âœ… Correctly rejected: ${error.message}`);
                }
            } catch (error) {
                addResult('error', 'Fail-Closed: Algorithm Mismatch', `Test setup error: ${error.message}`);
            }
        }

        async function testErrorHandling() {
            addResult('info', 'Error Handling Tests Started', 'Testing comprehensive error handling');

            // Test malformed encrypted data
            const malformedCases = [
                { name: 'Null encrypted data', data: null },
                { name: 'String encrypted data', data: 'invalid' },
                { name: 'Missing ciphertext', data: { algorithm: 'AES-256-GCM' } },
                { name: 'Non-string ciphertext', data: { ciphertext: 123, algorithm: 'AES-256-GCM' } },
                { name: 'Invalid base64', data: { ciphertext: 'not-base64!@#', algorithm: 'AES-256-GCM' } },
                { name: 'Too short ciphertext', data: { ciphertext: btoa('short'), algorithm: 'AES-256-GCM' } }
            ];

            for (const testCase of malformedCases) {
                try {
                    await boundaryTestCrypto.decrypt(testCase.data);
                    addResult('error', `Error Handling: ${testCase.name}`, 'âŒ SECURITY ISSUE: Accepted malformed data');
                } catch (error) {
                    addResult('success', `Error Handling: ${testCase.name}`, `âœ… Correctly rejected: ${error.message}`);
                }
            }

            // Test edge case conversions
            try {
                // Test maximum safe integer conversion
                const largeNumber = Number.MAX_SAFE_INTEGER;
                await boundaryTestCrypto.encrypt(largeNumber, { app: 'ccc-reference', version: 'phase2' });
                addResult('error', 'Error Handling: Large Number', 'âŒ Accepted large number without conversion');
            } catch (error) {
                addResult('success', 'Error Handling: Large Number', `âœ… Rejected large number: ${error.message}`);
            }
        }

        async function runAllBoundaryTests() {
            clearResults();
            addResult('info', 'Day 10 Boundary Tests Started', 'Running comprehensive boundary and error tests');

            try {
                await boundaryTestCrypto.initialize();
                addResult('success', 'Boundary Test Crypto Initialized', 'âœ… Test environment ready');
            } catch (error) {
                addResult('error', 'Boundary Test Crypto Failed', error.message);
                return;
            }

            await testTypeSafety();
            await testInputValidation();
            await testFailClosed();
            await testErrorHandling();

            addResult('info', 'Day 10 Validation Summary', 
                'ðŸŽ¯ Day 10 Boundary Tests Complete\n' +
                '=================================\n' +
                'âœ… Type safety validation working\n' +
                'âœ… Input validation with PII detection\n' +
                'âœ… Fail-closed behavior verified\n' +
                'âœ… Error handling comprehensive\n' +
                'âœ… Security boundaries enforced\n' +
                '\nðŸ“‹ Ready for Day 11: Chrome-only file size testing'
            );
        }

        // Auto-initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            addResult('info', 'Day 10 Boundary Test Page Loaded', 'Click "Run All Boundary Tests" to start comprehensive validation');
        });
    </script>
</body>
</html>
